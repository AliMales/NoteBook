# Python

## Django rest framework 

```shell
# 当有增量的model修改或者删除的时候 先删除编译缓存文件
find . -path "*/migrations/*.py" -not -name "__init__.py" -delete
find . -path "*/migrations/*.pyc"  -delete
#重新生成 makemigrations
python manage.py makemigrations
python manage.py migrate
# 后台部署 后台文件夹 /data/c18e/backend
ps aux|grep uwsgi
kill -9 PORT
uwsgi -d  --ini application/uwsgi.ini
# 前端部署 
yarn deploy
```



## Python多进程和多线程哪个快?

## 进程(process)

```python
from multiprocessing import Process,Pool
import time

def p_task(i):
    time.sleep(2)
    
if __name__=='__main__':
    # 单个
    p = Process(target=p_task, args=())
    
    p.start()
    p.join()
    
    # 多个
    pools = Pool(4)
    pools.apply_async(p_task, args=())
    pools.apply_async(p_task, args=())
    pools.close()
    pools.join()
```

## 线程(process)

```python
import threading
import time

def t_task(i):
    time.sleep(2)


if __name__=='__main__':
    t1 = threading.Thread(target=t_task, args=(1,))
    t2 = threading.Thread(target=t_task, args=(2,))
    t1.start()
    t2.start()

```



- 对CPU密集型代码(比如循环计算) - 多进程效率更高
- 对IO密集型代码(比如文件操作，网络爬虫) - 多线程效率更高

对于IO密集型操作，大部分消耗时间其实是等待时间，在等待时间中CPU是不需要工作的，那你在此期间提供双CPU资源也是利用不上的，相反对于CPU密集型代码，2个CPU干活肯定比一个CPU快很多。那么为什么多线程会对IO密集型代码有用呢？这时因为python碰到等待会释放GIL供新的线程使用，实现了线程间的切换。
