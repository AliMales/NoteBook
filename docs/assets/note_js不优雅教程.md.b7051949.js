import{_ as e,o as a,c as r,a as t}from"./app.a5d386c5.js";const i=JSON.parse('{"title":"不优雅代码指南","description":"","frontmatter":{},"headers":[{"level":2,"title":"如何编写","slug":"如何编写","link":"#如何编写","children":[]},{"level":2,"title":"第一条：打字越少越好","slug":"第一条-打字越少越好","link":"#第一条-打字越少越好","children":[]},{"level":2,"title":"第二条：变量/函数混合命名风格","slug":"第二条-变量-函数混合命名风格","link":"#第二条-变量-函数混合命名风格","children":[]},{"level":2,"title":"第三条：不要写注释","slug":"第三条-不要写注释","link":"#第三条-不要写注释","children":[]},{"level":2,"title":"第四条：使用母语写注释","slug":"第四条-使用母语写注释","link":"#第四条-使用母语写注释","children":[]},{"level":2,"title":"第五条：尽可能混合不同的格式","slug":"第五条-尽可能混合不同的格式","link":"#第五条-尽可能混合不同的格式","children":[]},{"level":2,"title":"第六条：尽可能把代码写成一行","slug":"第六条-尽可能把代码写成一行","link":"#第六条-尽可能把代码写成一行","children":[]},{"level":2,"title":"第七条：发现错误要保持静默","slug":"第七条-发现错误要保持静默","link":"#第七条-发现错误要保持静默","children":[]},{"level":2,"title":"第八条：广泛使用全局变量","slug":"第八条-广泛使用全局变量","link":"#第八条-广泛使用全局变量","children":[]},{"level":2,"title":"第九条：构建备用变量","slug":"第九条-构建备用变量","link":"#第九条-构建备用变量","children":[]},{"level":2,"title":"第十条：Type 使用需谨慎","slug":"第十条-type-使用需谨慎","link":"#第十条-type-使用需谨慎","children":[]},{"level":2,"title":"第十一条：准备「Plan B」","slug":"第十一条-准备「plan-b」","link":"#第十一条-准备「plan-b」","children":[]},{"level":2,"title":"第十二条：嵌套的三角法则","slug":"第十二条-嵌套的三角法则","link":"#第十二条-嵌套的三角法则","children":[]},{"level":2,"title":"第十三条：混合缩进","slug":"第十三条-混合缩进","link":"#第十三条-混合缩进","children":[]},{"level":2,"title":"第十四条：不要锁住依赖项","slug":"第十四条-不要锁住依赖项","link":"#第十四条-不要锁住依赖项","children":[]},{"level":2,"title":"第十五条：长函数比短函数好","slug":"第十五条-长函数比短函数好","link":"#第十五条-长函数比短函数好","children":[]},{"level":2,"title":"第十六条：代码不需要做特定测试","slug":"第十六条-代码不需要做特定测试","link":"#第十六条-代码不需要做特定测试","children":[]},{"level":2,"title":"第十七条：尽量避免重复代码","slug":"第十七条-尽量避免重复代码","link":"#第十七条-尽量避免重复代码","children":[]},{"level":2,"title":"第十八条：构建新项目不需要 README 文档","slug":"第十八条-构建新项目不需要-readme-文档","link":"#第十八条-构建新项目不需要-readme-文档","children":[]},{"level":2,"title":"第十九条：保存不必要的代码","slug":"第十九条-保存不必要的代码","link":"#第十九条-保存不必要的代码","children":[]}],"relativePath":"note/js不优雅教程.md"}'),l={name:"note/js不优雅教程.md"},c=[t('<h1 id="不优雅代码指南" tabindex="-1">不优雅代码指南 <a class="header-anchor" href="#不优雅代码指南" aria-hidden="true">#</a></h1><h2 id="如何编写" tabindex="-1">如何编写 <a class="header-anchor" href="#如何编写" aria-hidden="true">#</a></h2><p>在 GitHub 上有一个新项目，它描述了「最佳垃圾代码」的十九条关键准则。从变量命名到注释编写。这些准则将指导你写出最亮眼的烂代码。</p><p>为了保持与原 GitHub 项目一致的风格，下文没有进行转换。读者们可以以相反的角度来理解所有观点，这样就能完美避免写出垃圾代码。</p><p>项目地址：<a href="https://github.com/trekhleb/state-of-the-art-shitcode" target="_blank" rel="noreferrer">https://github.com/trekhleb/state-of-the-art-shitcode</a></p><p>当然，以下十九条垃圾代码书写准则并没有面面俱到，如果读者们发现有一些难以忍受的烂代码习惯，也可以发表你的看法。</p><h2 id="第一条-打字越少越好" tabindex="-1">第一条：<strong>打字越少越好</strong> <a class="header-anchor" href="#第一条-打字越少越好" aria-hidden="true">#</a></h2><p>如果我们键入的东西越少，那么就有越多的时间去思考代码逻辑等问题。如下所示，「Good」表示遵循该规则的示例，Bad 表示没遵循该规则的示例。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code1.png" alt="img"></p><h2 id="第二条-变量-函数混合命名风格" tabindex="-1">第二条：<strong>变量/函数混合命名风格</strong> <a class="header-anchor" href="#第二条-变量-函数混合命名风格" aria-hidden="true">#</a></h2><p>我们需要混合命名方法与变量，这样才能体现命名的多样性。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code2.png" alt="img"></p><h2 id="第三条-不要写注释" tabindex="-1">第三条：<strong>不要写注释</strong> <a class="header-anchor" href="#第三条-不要写注释" aria-hidden="true">#</a></h2><p>反正代码都看得懂，为什么要写注释？或者说，反正没人看我的代码，为什么要写注释？</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code3.png" alt="img"></p><h2 id="第四条-使用母语写注释" tabindex="-1">第四条：<strong>使用母语写注释</strong> <a class="header-anchor" href="#第四条-使用母语写注释" aria-hidden="true">#</a></h2><p>如果你违反了第三条规则，那么至少写注释需要用你的母语或者其它语言。如果你的母语是英语，那么你也算违反了这条规则。既然编程语言绝大多数都是用英文，那么为什么不用其它语言注释一下？</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code4.png" alt="img"></p><h2 id="第五条-尽可能混合不同的格式" tabindex="-1">第五条：<strong>尽可能混合不同的格式</strong> <a class="header-anchor" href="#第五条-尽可能混合不同的格式" aria-hidden="true">#</a></h2><p>同样，为了代码的多样性，我们需要尽可能混合不同的格式，例如单引号或双引号。如果它们的语义相同，那就应该混用。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code5.png" alt="img"></p><h2 id="第六条-尽可能把代码写成一行" tabindex="-1">第六条：<strong>尽可能把代码写成一行</strong> <a class="header-anchor" href="#第六条-尽可能把代码写成一行" aria-hidden="true">#</a></h2><p>如果一系列参数与方法都是一起实现的，那么代码也要写在一起。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code6.png" alt="img"></p><h2 id="第七条-发现错误要保持静默" tabindex="-1">第七条：<strong>发现错误要保持静默</strong> <a class="header-anchor" href="#第七条-发现错误要保持静默" aria-hidden="true">#</a></h2><p>当你发现某些错误时，其他人不需要了解它，因此不需要打印出日志或 Traceback。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code7.png" alt="img"></p><h2 id="第八条-广泛使用全局变量" tabindex="-1">第八条：<strong>广泛使用全局变量</strong> <a class="header-anchor" href="#第八条-广泛使用全局变量" aria-hidden="true">#</a></h2><p>使用全局变量，是面向「全球化」不可或缺的部分。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code9.png" alt="img"></p><h2 id="第九条-构建备用变量" tabindex="-1">第九条：<strong>构建备用变量</strong> <a class="header-anchor" href="#第九条-构建备用变量" aria-hidden="true">#</a></h2><p>以防万一，我们需要创建一些备用变量，在需要时随时调用它们。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code10.png" alt="img"></p><h2 id="第十条-type-使用需谨慎" tabindex="-1">第十条：<strong>Type 使用需谨慎</strong> <a class="header-anchor" href="#第十条-type-使用需谨慎" aria-hidden="true">#</a></h2><p>一般不要指定变量类型或者经常做类型检查，无类型才是最好的类型。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code11.png" alt="img"></p><h2 id="第十一条-准备「plan-b」" tabindex="-1">第十一条：<strong>准备「Plan B」</strong> <a class="header-anchor" href="#第十一条-准备「plan-b」" aria-hidden="true">#</a></h2><p>你需要准备一些运行不到的代码（unreachable code），它们可以作为你的「Plan B」。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><h2 id="第十二条-嵌套的三角法则" tabindex="-1">第十二条：<strong>嵌套的三角法则</strong> <a class="header-anchor" href="#第十二条-嵌套的三角法则" aria-hidden="true">#</a></h2><p>如果代码有一些嵌套结构，或者说缩进空行的结构，三角法则是最漂亮的。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><h2 id="第十三条-混合缩进" tabindex="-1">第十三条：<strong>混合缩进</strong> <a class="header-anchor" href="#第十三条-混合缩进" aria-hidden="true">#</a></h2><p>我们需要避免采用缩进，因为缩进会使复杂代码在编辑器中占用更多的空间。如果一定要采用缩进，那么就使用混合缩进策略。当然，这种策略在 Python 中是行不通的，因为它靠缩进来确定代码结构。</p><p><img src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" alt="img"></p><h2 id="第十四条-不要锁住依赖项" tabindex="-1">第十四条：<strong>不要锁住依赖项</strong> <a class="header-anchor" href="#第十四条-不要锁住依赖项" aria-hidden="true">#</a></h2><p>每一次要安装新库时，更新已有的依赖项。为什么要维持之前的版本呢，我们需要时刻保持最新的第三方代码库。</p><p><img src="https://c18e-1257416358.cos.accelerate.myqcloud.com/uPic/code13.png" alt="img"></p><h2 id="第十五条-长函数比短函数好" tabindex="-1">第十五条：<strong>长函数比短函数好</strong> <a class="header-anchor" href="#第十五条-长函数比短函数好" aria-hidden="true">#</a></h2><p>不要将程序整体逻辑分割为一些代码块，要是 IDE 突然不行了，它找不到必要的文件或函数怎么办。因此把代码写在一个主体函数中，并且不再维护额外的函数导入或代码文件，那么这样的方法是最稳定的。</p><p>单个文件一万行代码是没问题的，单个函数一千行代码也是没问题的。</p><h2 id="第十六条-代码不需要做特定测试" tabindex="-1">第十六条：<strong>代码不需要做特定测试</strong> <a class="header-anchor" href="#第十六条-代码不需要做特定测试" aria-hidden="true">#</a></h2><p>这些测试通常是重复且无意义的工作。</p><h2 id="第十七条-尽量避免重复代码" tabindex="-1">第十七条：<strong>尽量避免重复代码</strong> <a class="header-anchor" href="#第十七条-尽量避免重复代码" aria-hidden="true">#</a></h2><p>按你的想法写代码，尤其是在小团队中，毕竟这是「自由」准则。</p><h2 id="第十八条-构建新项目不需要-readme-文档" tabindex="-1">第十八条：<strong>构建新项目不需要 README 文档</strong> <a class="header-anchor" href="#第十八条-构建新项目不需要-readme-文档" aria-hidden="true">#</a></h2><p>在项目前期，我们可以暂时保持这种状态。</p><h2 id="第十九条-保存不必要的代码" tabindex="-1">第十九条：<strong>保存不必要的代码</strong> <a class="header-anchor" href="#第十九条-保存不必要的代码" aria-hidden="true">#</a></h2><p>在写代码的过程中，经常会产生很多测试代码。这些代码也是非常重要的资料，因此不能删除掉，最多只能注释掉。</p>',59)];const h=e(l,[["render",function(e,t,i,l,h,n){return a(),r("div",null,c)}]]);export{i as __pageData,h as default};
